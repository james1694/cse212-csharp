Queue in C#
Overview
A queue is a data structure that follows the First-In-First-Out (FIFO) principle. 
The first element added to the queue is the first one to be removed. Queues are used in various scenarios like scheduling processes, 
managing tasks in order, or handling requests in web servers.

Key Operations
Enqueue: Adds an element to the end of the queue.
Dequeue: Removes and returns the element from the front of the queue.
Peek: Returns the element at the front of the queue without removing it.
IsEmpty: Checks if the queue is empty.
Count: Returns the number of elements in the queue.
Implementation
In C#, you can use the Queue<T> class from the System.Collections.Generic namespace. 
Below is a simple implementation and usage of a queue in C#.

class Program
{
    static void Main()
    {
        Queue<int> queue = new Queue<int>();
        queue.Enqueue(1);
        queue.Enqueue(2);
        queue.Enqueue(3);
        Console.WriteLine("Front element: " + queue.Peek());
        Console.WriteLine("Dequeued: " + queue.Dequeue());
        Console.WriteLine("Dequeued: " + queue.Dequeue());
        Console.WriteLine("Is queue empty? " + (queue.Count == 0));
        queue.Enqueue(4);
        Console.WriteLine("Number of elements in queue: " + queue.Count);
        while (queue.Count > 0)
        {
            Console.WriteLine("Dequeued: " + queue.Dequeue());
        }
        Console.WriteLine("Is queue empty? " + (queue.Count == 0));
    }
}

Custom Queue Implementation
For educational purposes, here's a custom implementation of a queue using a linked list:
using System;

public class Node<T>
{
    public T Data { get; set; }
    public Node<T> Next { get; set; }

    public Node(T data)
    {
        Data = data;
        Next = null;
    }
}

public class CustomQueue<T>
{
    private Node<T> head;
    private Node<T> tail;
    private int count;

    public CustomQueue()
    {
        head = null;
        tail = null;
        count = 0;
    }

    public void Enqueue(T item)
    {
        Node<T> newNode = new Node<T>(item);
        if (tail != null)
        {
            tail.Next = newNode;
        }
        tail = newNode;
        if (head == null)
        {
            head = tail;
        }
        count++;
    }

    public T Dequeue()
    {
        if (head == null)
        {
            throw new InvalidOperationException("Queue is empty.");
        }
        T value = head.Data;
        head = head.Next;
        if (head == null)
        {
            tail = null;
        }
        count--;
        return value;
    }

    public T Peek()
    {
        if (head == null)
        {
            throw new InvalidOperationException("Queue is empty.");
        }
        return head.Data;
    }

    public int Count => count;

    public bool IsEmpty => count == 0;
}

class Program
{
    static void Main()
    {
        CustomQueue<int> queue = new CustomQueue<int>();

        queue.Enqueue(1);
        queue.Enqueue(2);
        queue.Enqueue(3);

        Console.WriteLine("Front element: " + queue.Peek());

        Console.WriteLine("Dequeued: " + queue.Dequeue());
        Console.WriteLine("Dequeued: " + queue.Dequeue());

        Console.WriteLine("Is queue empty? " + queue.IsEmpty);

        queue.Enqueue(4);

        Console.WriteLine("Number of elements in queue: " + queue.Count);

        while (!queue.IsEmpty)
        {
            Console.WriteLine("Dequeued: " + queue.Dequeue());
        }

        Console.WriteLine("Is queue empty? " + queue.IsEmpty);
    }
}

Conclusion
Understanding queues and their operations is fundamental in computer science. The provided examples illustrate both the use of the
built-in Queue<T> class and a custom implementation, demonstrating the core principles and operations of a queue.
